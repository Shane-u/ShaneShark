name: Deploy Backend to Server

on:
  push:
    branches: [ "main", "master" ]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'
  workflow_dispatch:

env:
  APP_NAME: shaneshark-backend
  APP_PORT: 8121
  DEPLOY_PATH: /root/project/shaneshark_backend
  JAR_NAME: shaneShark-0.0.1-SNAPSHOT.jar

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Java 17 环境
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: temurin
          cache: maven

      - name: Maven 构建（包含测试）
        run: |
          echo "开始 Maven 构建..."
          mvn -B -ntp clean package || {
            echo "Maven 构建失败，尝试跳过测试..."
            mvn -B -ntp clean package -DskipTests
          }
          echo "Maven 构建完成"

      - name: 验证 JAR 文件是否存在
        run: |
          if [ ! -f "target/${{ env.JAR_NAME }}" ]; then
            echo "错误: JAR 文件不存在"
            echo "当前目录: $(pwd)"
            echo "查找 JAR 文件:"
            find . -name "*.jar" -type f || echo "未找到任何 JAR 文件"
            echo "target 目录内容:"
            ls -la target/ || echo "target 目录不存在"
            exit 1
          fi
          echo "JAR 文件验证成功: target/${{ env.JAR_NAME }}"
          ls -lh "target/${{ env.JAR_NAME }}"

      - name: 配置 SSH 凭据
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: 加入服务器指纹
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          echo "服务器指纹已添加"
        shell: bash

      - name: 测试 SSH 连接
        env:
          SSH_TARGET: ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}
        run: |
          echo "测试 SSH 连接..."
          ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=10 "$SSH_TARGET" "echo 'SSH 连接成功' && whoami && pwd" || {
            echo "SSH 连接失败，请检查："
            echo "1. SSH_PRIVATE_KEY secret 是否正确配置（需要包含完整的私钥，包括 -----BEGIN 和 -----END 行）"
            echo "2. 服务器上的 ~/.ssh/authorized_keys 是否包含对应的公钥"
            echo "3. 服务器用户是否有正确的权限"
            echo "4. 服务器防火墙是否允许 SSH 连接"
            exit 1
          }

      - name: 传输 JAR 文件到服务器
        env:
          SSH_TARGET: ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}
        run: |
          echo "开始传输 JAR 文件..."
          echo "源文件: target/${{ env.JAR_NAME }}"
          echo "目标: $SSH_TARGET:${{ env.DEPLOY_PATH }}/app.jar"
          # 由于 working-directory 是 backend，所以路径是 target/xxx.jar
          scp -v -o StrictHostKeyChecking=no target/${{ env.JAR_NAME }} "$SSH_TARGET:${{ env.DEPLOY_PATH }}/app.jar" || {
            echo "文件传输失败"
            exit 1
          }
          echo "文件传输成功"
          echo "注意: SQLite 数据库文件不会上传，应用启动时会自动在服务器上创建并初始化数据库"

      - name: 远程部署应用
        env:
          SSH_TARGET: ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}
          APP_NAME: ${{ env.APP_NAME }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
          APP_PORT: ${{ env.APP_PORT }}
        run: |
          ssh "$SSH_TARGET" bash -s << 'REMOTE_SCRIPT'
            set -e
            APP_NAME="${{ env.APP_NAME }}"
            DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
            
            # 确保部署目录存在
            mkdir -p "$DEPLOY_PATH"
            
            # 确保 data 目录存在（SQLite 数据库目录）
            # 注意：数据库文件不会从本地上传，应用启动时会自动创建数据库文件和表结构
            # 数据库文件会在服务器上持久化，每次部署不会覆盖已有数据
            mkdir -p "$DEPLOY_PATH/data"
            
            # 停止旧进程（如果存在）
            if systemctl is-active --quiet "$APP_NAME" 2>/dev/null; then
              echo "停止 systemd 服务..."
              systemctl stop "$APP_NAME" || true
            fi
            
            # 查找并停止可能正在运行的 Java 进程
            OLD_PID=$(pgrep -f "java.*app.jar" || true)
            if [ ! -z "$OLD_PID" ]; then
              echo "停止旧进程 PID: $OLD_PID"
              kill -15 "$OLD_PID" || true
              sleep 2
              if kill -0 "$OLD_PID" 2>/dev/null; then
                kill -9 "$OLD_PID" || true
              fi
            fi
            
            # 检查 systemd 服务文件是否存在，不存在则创建
            SERVICE_FILE="/etc/systemd/system/${APP_NAME}.service"
            if [ ! -f "$SERVICE_FILE" ]; then
              echo "创建 systemd 服务文件..."
              sudo bash -c "printf '%s\n' \
                '[Unit]' \
                'Description=ShaneShark Backend Application' \
                'After=network.target' \
                '' \
                '[Service]' \
                'Type=simple' \
                'User=root' \
                \"WorkingDirectory=$DEPLOY_PATH\" \
                'EnvironmentFile=/root/envFiles/.env' \
                \"ExecStart=/usr/bin/java -jar $DEPLOY_PATH/app.jar\" \
                'Restart=always' \
                'RestartSec=10' \
                'StandardOutput=journal' \
                'StandardError=journal' \
                '' \
                '[Install]' \
                'WantedBy=multi-user.target' > $SERVICE_FILE"
              systemctl daemon-reload
              systemctl enable "$APP_NAME"
            fi
            
            # 启动服务
            echo "启动应用服务..."
            systemctl start "$APP_NAME"
            
            # 等待服务启动
            sleep 3
            
            # 检查服务状态
            if systemctl is-active --quiet "$APP_NAME"; then
              echo "应用启动成功！"
              systemctl status "$APP_NAME" --no-pager -l
            else
              echo "应用启动失败，查看日志："
              journalctl -u "$APP_NAME" -n 50 --no-pager
              exit 1
            fi
          REMOTE_SCRIPT

